//---------------------------------------------------------------------------------------------
//	Fibonacci test code for EMZ1001 (c) 2022-... zpekic@hotmail.com
//  Compile with https://github.com/zpekic/MicroCodeCompiler
//---------------------------------------------------------------------------------------------
// Test code to load into internal 1k ROM of Iskra EMZ1001 (AMI S2000) 4-bit microcontroller
// http://www.bitsavers.org/components/ami/s2000/
// Full description: (TBD link to hackaday project)
//---------------------------------------------------------------------------------------------
			.code 10, 8, fibonacci_code.mif, fibonacci_code.cgf, fibonacci_code.coe, emz:fibonacci_code.vhd, fibonacci_code.hex, fibonacci_code.bin, 1;
			.symbol 10, 256, fibonacci_sym.mif, fibonacci_sym.cgf, fibonacci_sym.coe, emz:fibonacci_sym.vhd, fibonacci_sym.hex, fibonacci_sym.bin, 32;

#include "emz1001.mcc";

CR:			.alias 0xD;
LF:			.alias 0xA;

			.org 0;
//	Execution starts at bank 0, page 0, location 0
//	---------------------------------------------------------------------------
			NOP;
			//val6 = -(-(-7 + 0xA));
			//val6 = 0x3F & ((1 | (15 * 15)) - 256);
			//val6 = (0b1010 | 0b0101) * 2;
			//val6 = (5 + (7 / 2)) * 3;
			//val6 = -!(0o7 ^ (7 % 3));
			
			LAI 0b1000;		// bit3 = 50Hz, bit0 = invert D lines on output
			EUR;			// set prescaler and inverter
			
			LBZ 0;			// select RAM column 0, row 0
			JMS  CLEAR;		// clear RAM column 0
			
			LBZ 1;			// select RAM column 1, row 0
			JMS  CLEAR; 	// clear RAM column 1
			
			LBZ 1;			// select digit 0 in RAM column 1
			STM 0;			// RAM[1,0] = 1
			
ADDLOOP:	JMS  BCDADD;	// RAM[2,*] = RAM[1,*] + RAM[2,*]
			PP 14;			// prepare for page 14 (instead of usual 15)
			JMS  DISP_TTY;	// display to "teletype" (ASCII sequence output)

DISPLOOP:	NOP; //JMS  DISP_LED;	// display to 7-seg LEDs 
			SOS;			// check if 1 second lapsed
			JMP DISPLOOP;	// no, continue refreshing LEDs as fast as possible
			
			JMS  SHIFT0;	// RAM[0,*] = RAM[1,*]
			
			JMS  SHIFT1;	// RAM[1,*] = RAM[2,*]
			
			JMP ADDLOOP;	// RAM[0,*] and RAM[1,*] contain last two Fibonacci numbers, continue

			.org 0b1110000000;
//	Page 14 as an "overflow" from busy subroutine page 15
// ----------------------------------------------------------------------------
DISP_TTY:	LBF 0b10;		// select current Fibonacci number column (2), BL = 15
			PSL;			// set all A lines low
			XCD 0b00;		// BL = 14, keep BU
			PSH;			// drive D lines, do not float them
			XCD 0b00;		// BL = 13, keep BU
			PSL;			// set static operation 
			XCD 0b00;		// start displaying at digit 12 (9999999999999)
TTYLOOP:	LAI 3;			// ASCII digits 0..9 are hex 0x30 to 0x39
			XC 0;			// keep BU, M.A is now 3.x
			OUT;			// D pins <= 3X, strobe EXT low
			XCD	0b00;		// next, do not change column
			JMP TTYLOOP;
			RSM 3;
			RSM 2;
			RSM 1;
			RSM 0;			// clear M[BU, BL]
			LAI CR;			// BL is 15, which is assumed to be 0
			OUT;
			LAI LF;		
			OUT;			// CR+LF sequence to go to next line
			RT;

			.org 0b1111000000;
//	Page 15 in the bank is the default place for subroutines
// ----------------------------------------------------------------------------
CLEAR:		LAI 0;			// A = 0, BU set by caller
			XCI 0;			// Exchange with M[BU, BL], BU = BU, BL++
			JMP CLEAR;		// repeat until all covered (BU = 0)
			RT;				// back
			
SHIFT0:		LBZ 0b01;		// row (BL) = 0, col (BU) = 1
SHIFT0LOOP:	LAM 0b01;		// A = M[1, BL], BU = 0 (LSB flipped)
			XCI 0b01;		// exchange with M[0, BL], BU = 1 (LSB flipped back), BL++
			JMP SHIFT0LOOP;	// repeat until all moved from column 1 to 0
			RT;				
			
SHIFT1:		LBZ 0b10;		// start with column 2
SHIFT1LOOP:	LAM 0b11;		// switch to column 1 (both bits flipped!)
			XCI 0b11;		// switch back to column 2		
			JMP SHIFT1LOOP;
			RT;

DISP_LED:	LBF 0b10;		// select current Fibonacci number column (2), BL = 15
			PSL;			// set all A lines low
			XCD 0b00;		// BL = 14, keep BU
			PSH;			// drive D lines, do not float them
			XCD 0b00;		// BL = 13, keep BU
			PSL;			// set static operation 
			XCD 0b00;		// start displaying at digit 12 (9999999999999)
			RSC;			// no decimal point displayed
LEDLOOP:	LAM 0b00;		// A <= M[BL, BU]
			PSH;			// prepare anode selected by [BL] high
			MVS;			// update A pins (A[BL] <= '1')
			DISN;			// Cathodes from A 7-seg decode
			NOP;			// delay to keep it lit for a bit
			NOP;
			NOP;
			PSL;			// anode off
			MVS;			// update A pins (A[BL] <= '0')
			XCD	0b00;		// next, do not change column
			JMP LEDLOOP;	
			RT;

BCDADD:		LBZ 0;			// BL = 0, BU = 0
			RSC;			// clear carry
ALOOP:		LAM 0b01;		// A = M[0, BL], BU = 1
			ADCS;			// C,A = A + M[1, BU] + C
			JMS V16_TO_18;	// carry set
			JMS V0_TO_15;	// carry not set
			XAE;			// save A in E
			LAI 2;			// A = 2
			XABU;			// BU = 2
			XAE;			// restore A
			XCI 0b10;		// M[2, BL] = A, BU = 0
			JMP ALOOP;		// repeat until all 16 digits
			RT;				// done

V0_TO_15:	XAE;
			LAE;			// E = A
			ADIS 6;			// Classic DAA adjust
			RT;				// carry set, adjustment was needed, A is correct BCD
			XAE;			// carry not set, adjustment was not needed, restore A
			RT;
			
V16_TO_18:	ADIS 5;		// 0x12 + 5 + 1 becomes 0x18 etc., carry remains set
			STC;		// decimal carry forward
			RTS;		// skip next
						